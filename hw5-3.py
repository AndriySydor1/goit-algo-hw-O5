''' Розробіть Python-скрипт для аналізу файлів логів.
 Скрипт повинен вміти читати лог-файл, переданий як аргумент командного рядка, і виводити статистику за рівнями логування наприклад, INFO, ERROR, DEBUG.
Також користувач може вказати рівень логування як другий аргумент командного рядка, щоб отримати всі записи цього рівня.
Файли логів – це файли, що містять записи про події, які відбулися в операційній системі, програмному забезпеченні або інших системах.
Вони допомагають відстежувати та аналізувати поведінку системи, виявляти та діагностувати проблеми.
Для виконання завдання візьміть наступний приклад лог-файлу:
2024-01-22 08:30:01 INFO User logged in successfully.
2024-01-22 08:45:23 DEBUG Attempting to connect to the database.
2024-01-22 09:00:45 ERROR Database connection failed.
2024-01-22 09:15:10 INFO Data export completed.
2024-01-22 10:30:55 WARNING Disk usage above 80%.
2024-01-22 11:05:00 DEBUG Starting data backup process.
2024-01-22 11:30:15 ERROR Backup process failed.
2024-01-22 12:00:00 INFO User logged out.
2024-01-22 12:45:05 DEBUG Checking system health.
2024-01-22 13:30:30 INFO Scheduled maintenance.
Вимоги до завдання:
Скрипт повинен приймати шлях до файлу логів як аргумент командного рядка.
Скрипт повинен приймати не обов'язковий аргумент командного рядка, після аргументу шляху до файлу логів. Він відповідає за виведення всіх записи певного рівня логування.
І приймає значення відповідно до рівня логування файлу. Наприклад аргумент error виведе всі записи рівня ERROR з файлу логів.
Скрипт має зчитувати і аналізувати лог-файл, підраховуючи кількість записів для кожного рівня логування (INFO, ERROR, DEBUG, WARNING).
Реалізуйте функцію parse_log_line(line: str) -> dict для парсингу рядків логу.
Реалізуйте функцію load_logs(file_path: str) -> list для завантаження логів з файлу.
Реалізуйте функцію filter_logs_by_level(logs: list, level: str) -> list для фільтрації логів за рівнем.
Реалізуйте функцію count_logs_by_level(logs: list) -> dict для підрахунку записів за рівнем логування.
Результати мають бути представлені у вигляді таблиці з кількістю записів для кожного рівня. Для цього реалізуйте функцію display_log_counts(counts: dict), яка форматує та виводить результати.
Вона приймає результати виконання функції count_logs_by_level.
Рекомендації для виконання:
Перш ніж почати, ознайомтеся зі структурою вашого лог-файлу. Зверніть увагу на формат дати та часу, рівні логування INFO, ERROR, DEBUG, WARNING і структуру повідомлень.
Зрозумійте, як розділені різні компоненти логу, це зазвичай пробіли або спеціальні символи.
Розділіть ваше завдання на логічні блоки і функції для кращої читабельності і подальшого розширення.
Парсинг рядка логу виконує ****функцію parse_log_line(line: str) -> dict, яка приймає рядок з логу як вхідний параметр і повертає словник з розібраними компонентами: дата, час, рівень, повідомлення.
Використовуйте методи рядків, такі як split(), для розділення рядка на частини.
Завантаження лог-файлів виконує функція load_logs(file_path: str) -> list, що відкриває файл, читає кожен рядок і застосовує на нього функцію parse_log_line, зберігаючи результати в список.
Фільтрацію за рівнем логування виконує функція filter_logs_by_level(logs: list, level: str) -> list. Вона дозволить вам отримати всі записи логу для певного рівня логування.
Підрахунок записів за рівнем логування повинна робити функція count_logs_by_level(logs: list) -> dict, яка проходить по всім записам і підраховує кількість записів для кожного рівня логування.
Вивід результатів виконайте за допомоги функції display_log_counts(counts: dict), яка форматує та виводить результати підрахунку в читабельній формі.
Ваш скрипт повинен вміти обробляти різні види помилок, такі як відсутність файлу або помилки при його читанні. Використовуйте блоки try/except для обробки виняткових ситуацій.
Критерії оцінювання:
Скрипт виконує всі зазначені вимоги, правильно аналізуючи лог-файли та виводячи інформацію.
Скрипт коректно обробляє помилки, такі як неправильний формат лог-файлу або відсутність файлу.
При розробці обов'язково було використано один з елементів функціонального програмування: лямбда-функція, списковий вираз, функція filter, тощо.
Код добре структурований, зрозумілий і містить коментарі там, де це необхідно.

 '''
import sys
import re
from collections import defaultdict

def parse_log_line(line: str) -> dict:
    # Регулярний вираз для парсингу рядка логу
    pattern = re.compile(r'(?P<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) (?P<level>\w+) (?P<message>.+)')
    match = pattern.match(line)
    
    if match:
        return match.groupdict()
    else:
        return {}

def load_logs(file_path: str) -> list:
    # Завантаження логів з файлу
    with open(file_path, 'r') as file:
        logs = [line.strip() for line in file if line.strip()]
    return logs

def filter_logs_by_level(logs: list, level: str) -> list:
    # Фільтрація логів за рівнем логування
    return [log for log in logs if parse_log_line(log).get('level') == level]

def count_logs_by_level(logs: list) -> dict:
    # Підрахунок записів за рівнем логування
    counts = defaultdict(int)
    for log in logs:
        level = parse_log_line(log).get('level')
        counts[level] += 1
    return counts

def display_log_counts(counts: dict):
    # Виведення результатів у вигляді таблиці
    print("Log Level\tCount")
    print("--------------------")
    for level, count in counts.items():
        print(f"{level}\t\t{count}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python log_analyzer.py <log_file_path> [log_level]")
        sys.exit(1)

    log_file_path = sys.argv[1]
    logs = load_logs(log_file_path)

    if len(sys.argv) == 3:
        log_level = sys.argv[2].upper()
        filtered_logs = filter_logs_by_level(logs, log_level)
        counts = count_logs_by_level(filtered_logs)
        display_log_counts(counts)
    else:
        counts = count_logs_by_level(logs)
        display_log_counts(counts)

'''
Цей скрипт приймає шлях до файлу логів як аргумент командного рядка.
 Якщо вказано додатковий аргумент рівня логування, він виводить статистику тільки для цього рівня. 
 Якщо аргумент не вказано, виводить загальну статистику за всі рівні.

'''
